on:
  workflow_call:
    inputs:
      cluster_name:
        type: string
        default: hello-pdf
        required: false

    secrets:
      aws_access_key_id:
        required: true
      aws_secret_access_key:
        required: true
      aws_account_id:
        required: true
      ssh_key:
        required: true
      slack_lambda_endpoint:
        required: true
      slack_api_secret:
        required: true

env:
  DOCKER_BUILDKIT: 1
  DOCKER_IMAGE_PREFIX: "agendrix-${{ inputs.cluster_name }}"
  AWS_REGION: ca-central-1
  SERVICE_DEPLOYMENT_TIMEOUT: 15
  NODE_ENV: production
  # TODO: Fix
  PING_SLACK: false

jobs:
  pre-build:
    name: Pre-build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Login to AWS
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.aws_access_key_id }}
          aws-secret-access-key: ${{ secrets.aws_secret_access_key }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Fetch current stable app image details
        id: fetch-app-image-details
        run: .github/actions/aws/get-running-image-details.sh
        continue-on-error: true
        env:
          cluster: ${{ inputs.cluster_name }}
          service: app
          container: app

      - name: Ping Slack
        if: env.PING_SLACK == 'true'
        uses: agendrix/slack-notifier/ping-slack@v1.0.2
        with:
          state: "STARTED"
          lambda-url: ${{ secrets.slack_lambda_endpoint }}
          api-secret: ${{ secrets.slack_api_secret }}
          previous-sha: ${{ steps.fetch-app-image-details.outputs.image_version }}

      - name: Get commit hash for image tag
        run: echo "::set-output name=image_tag::$(echo $GITHUB_SHA | cut -c 1-7)"
        id: get-hash

    outputs:
      image_tag: ${{ steps.get-hash.outputs.image_tag }}

  build-images:
    needs: [pre-build]
    name: Build Images
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Login to AWS
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.aws_access_key_id }}
          aws-secret-access-key: ${{ secrets.aws_secret_access_key }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Use SSH
        uses: agendrix/actions/use-ssh@master
        with:
          ssh-key: ${{ secrets.ssh_key }}

      - name: Build and push nginx to ECR
        id: build-nginx
        uses: agendrix/actions/aws/build-and-push-to-ecr@master
        with:
          ecr_registry: ${{ steps.login-ecr.outputs.registry }}
          image: ${{ env.DOCKER_IMAGE_PREFIX }}/nginx
          tag: ${{ needs.pre-build.outputs.image_tag }}
          path: "docker/nginx"

      - name: Build and push app to ECR
        id: build-app
        uses: agendrix/actions/aws/build-and-push-to-ecr@master
        with:
          ecr_registry: ${{ steps.login-ecr.outputs.registry }}
          image: "${{ env.DOCKER_IMAGE_PREFIX }}/app"
          tag: ${{ needs.pre-build.outputs.image_tag }}
          args: >-
            --ssh default
            --build-arg NODE_ENV=${{ env.NODE_ENV }}
          path: "."
          file: "docker/app/Dockerfile"

    outputs:
      nginx_image: ${{ steps.build-nginx.outputs.image }}
      app_image: ${{ steps.build-app.outputs.image }}

  deploy:
    name: Deploy nginx | app | worker | events-logger
    runs-on: ubuntu-latest
    needs: [build-images]
    strategy:
      fail-fast: false
      matrix:
        service: [nginx, app, worker, events-logger]
        include:
          - service: nginx
            image: ${{ needs.build-images.outputs.nginx_image }}
            secrets_path: aws/container-definitions/nginx.secrets.json
          - service: app
            image: ${{ needs.build-images.outputs.app_image }}
            secrets_path: aws/container-definitions/app.secrets.json
          - service: worker
            image: ${{ needs.build-images.outputs.app_image }}
            secrets_path: aws/container-definitions/app.secrets.json
          - service: events-logger
            image: ${{ needs.build-images.outputs.app_image }}
            secrets_path: aws/container-definitions/app.secrets.json
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Login to AWS
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.aws_access_key_id }}
          aws-secret-access-key: ${{ secrets.aws_secret_access_key }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ping Slack
        if: env.PING_SLACK == 'true'
        uses: agendrix/slack-notifier/ping-slack@v1.0.2
        with:
          state: "DEPLOYING"
          lambda-url: ${{ secrets.slack_lambda_endpoint }}
          api-secret: ${{ secrets.slack_api_secret }}

      - name: Create ${{ matrix.service }} task definition
        id: task-definition
        uses: agendrix/build-task-definition-action@v1.0.1
        with:
          cluster: ${{ inputs.cluster_name }}
          service: ${{ matrix.service }}
          image: ${{ secrets.aws_account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ matrix.image }}
          secrets_path: ${{ matrix.secrets_path }}
          container_definitions_path: aws/container-definitions/${{ matrix.service }}.json

      - name: Deploy ${{ matrix.service }} service to Amazon ECS
        if: steps.task-definition.outputs.should_deploy == 'true'
        id: deploy-task-definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          cluster: ${{ inputs.cluster_name }}
          service: ${{ matrix.service }}
          task-definition: ${{ steps.task-definition.outputs.path }}
          wait-for-service-stability: false

      - name: Wait for ${{ matrix.service }} service deployment to complete
        if: steps.deploy-task-definition.conclusion != 'skipped'
        id: wait-for-ecs-service-deployment
        uses: agendrix/wait-for-ecs-service-deployment-action@v1.0.0
        with:
          cluster: ${{ inputs.cluster_name }}
          service: ${{ matrix.service }}
          task-definition-arn: ${{ steps.deploy-task-definition.outputs.task-definition-arn }}
          deployment-timeout-minutes: ${{ env.SERVICE_DEPLOYMENT_TIMEOUT }}

      - name: Rollback ${{ matrix.service }} service to latest stable task definition
        if: failure() && steps.wait-for-ecs-service-deployment.conclusion == 'failure'
        id: deployment-rollback
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          cluster: ${{ inputs.cluster_name }}
          service: ${{ matrix.service }}
          task-definition: ${{ steps.task-definition.outputs.current_stable_task_definition_path }}
          wait-for-service-stability: false

      - name: Wait for ${{ matrix.service }} rollback to complete
        if: failure() && steps.deployment-rollback.conclusion != 'skipped'
        uses: agendrix/wait-for-ecs-service-deployment-action@v1.0.0
        with:
          cluster: ${{ inputs.cluster_name }}
          service: ${{ matrix.service }}
          task-definition-arn: ${{ steps.deployment-rollback.outputs.task-definition-arn }}
          deployment-timeout-minutes: ${{ env.SERVICE_DEPLOYMENT_TIMEOUT }}

  notify-slack:
    name: Notify Outcome to Slack
    runs-on: ubuntu-latest
    if: always()
    needs:
      - pre-build
      - build-images
      - deploy

    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - if: env.PING_SLACK == 'true'
        name: Determine workflow run state
        uses: actions/github-script@v4
        id: workflow-run-state
        env:
          NEEDS_CONTEXT: ${{ toJson(needs) }}
        with:
          script: |
            const { getWorkflowEndState } = require("./.github/scripts/getWorkflowEndState.js");
            getWorkflowEndState(core);

      - if: |
          env.PING_SLACK == 'true' &&
          steps.workflow-run-state.outputs.state == 'SUCCEEDED' &&
          needs.deploy.outputs.deployment_outcome == 'skipped'
        name: Ping Slack for skipped
        id: ping-for-skipped
        uses: agendrix/slack-notifier/ping-slack@v1.0.5
        with:
          state: "SKIPPED"
          lambda-url: ${{ secrets.slack_lambda_endpoint }}
          api-secret: ${{ secrets.slack_api_secret }}

      - if: env.PING_SLACK == 'true' && steps.ping-for-skipped.conclusion == 'skipped'
        name: Ping Slack for outcome
        uses: agendrix/slack-notifier/ping-slack@v1.0.5
        with:
          state: ${{ steps.workflow-run-state.outputs.state }}
          lambda-url: ${{ secrets.slack_lambda_endpoint }}
          api-secret: ${{ secrets.slack_api_secret }}
